"use strict";

/* @minVersion 7.20.0 */

/**
  Enums are used in this file, but not assigned to vars to avoid non-hoistable values

  CONSTRUCTOR = 0;
  PUBLIC = 1;
  PRIVATE = 2;

  FIELD = 0;
  ACCESSOR = 1;
  METHOD = 2;
  GETTER = 3;
  SETTER = 4;

  STATIC = 5;

  CLASS = 10; // only used in assertValidReturnValue
*/

function _apply_decs_2203_r(targetClass, memberDecs, classDecs, parentClass) {
    function createAddInitializerMethod(initializers, decoratorFinishedRef) {
        return function addInitializer(initializer) {
            assertNotFinished(decoratorFinishedRef, "addInitializer");
            assertCallable(initializer, "An initializer");
            initializers.push(initializer);
        };
    }

    function memberDec(dec, name, desc, initializers, kind, isStatic, isPrivate, metadata, value) {
        var kindStr;

        switch (kind) {
            case 1 /* ACCESSOR */:
                kindStr = "accessor";
                break;
            case 2 /* METHOD */:
                kindStr = "method";
                break;
            case 3 /* GETTER */:
                kindStr = "getter";
                break;
            case 4 /* SETTER */:
                kindStr = "setter";
                break;
            default:
                kindStr = "field";
        }

        var ctx = { kind: kindStr, name: isPrivate ? "#" + name : name, static: isStatic, private: isPrivate, metadata: metadata };

        var decoratorFinishedRef = { v: false };

        ctx.addInitializer = createAddInitializerMethod(initializers, decoratorFinishedRef);

        var get, set;
        if (kind === 0 /* FIELD */) {
            if (isPrivate) {
                get = desc.get;
                set = desc.set;
            } else {
                get = function() {
                    return this[name];
                };
                set = function(v) {
                    this[name] = v;
                };
            }
        } else if (kind === 2 /* METHOD */) {
            get = function() {
                return desc.value;
            };
        } else {
            // replace with values that will go through the final getter and setter
            if (kind === 1 /* ACCESSOR */ || kind === 3 /* GETTER */) {
                get = function() {
                    return desc.get.call(this);
                };
            }

            if (kind === 1 /* ACCESSOR */ || kind === 4 /* SETTER */) {
                set = function(v) {
                    desc.set.call(this, v);
                };
            }
        }
        ctx.access = get && set ? { get: get, set: set } : get ? { get: get } : { set: set };

        try {
            return dec(value, ctx);
        } finally {
            decoratorFinishedRef.v = true;
        }
    }

    function assertNotFinished(decoratorFinishedRef, fnName) {
        if (decoratorFinishedRef.v) {
            throw new Error("attempted to call " + fnName