#ifndef SRC_NAPI_INL_H_
#define SRC_NAPI_INL_H_

////////////////////////////////////////////////////////////////////////////////
// Node-API C++ Wrapper Classes
//
// Inline header-only implementations for "Node-API" ABI-stable C APIs for
// Node.js.
////////////////////////////////////////////////////////////////////////////////

// Note: Do not include this file directly! Include "napi.h" instead.

#include <algorithm>
#include <cstring>
#if NAPI_HAS_THREADS
#include <mutex>
#endif  // NAPI_HAS_THREADS
#include <type_traits>
#include <utility>

namespace Napi {

#ifdef NAPI_CPP_CUSTOM_NAMESPACE
namespace NAPI_CPP_CUSTOM_NAMESPACE {
#endif

// Helpers to handle functions exposed from C++ and internal constants.
namespace details {

// New napi_status constants not yet available in all supported versions of
// Node.js releases. Only necessary when they are used in napi.h and napi-inl.h.
constexpr int napi_no_external_buffers_allowed = 22;

// Attach a data item to an object and delete it when the object gets
// garbage-collected.
// TODO: Replace this code with `napi_add_finalizer()` whenever it becomes
// available on all supported versions of Node.js.
template <typename FreeType>
inline napi_status AttachData(napi_env env,
                              napi_value obj,
                              FreeType* data,
                              napi_finalize finalizer = nullptr,
                              void* hint = nullptr) {
  napi_status status;
  if (finalizer == nullptr) {
    finalizer = [](napi_env /*env*/, void* data, void* /*hint*/) {
      delete static_cast<FreeType*>(data);
    };
  }
#if (NAPI_VERSION < 5)
  napi_value symbol, external;
  status = napi_create_symbol(env, nullptr, &symbol);
  if (status == napi_ok) {
    status = napi_create_external(env, data, finalizer, hint, &external);
    if (status == napi_ok) {
      napi_property_descriptor desc = {nullptr,
                                       symbol,
                                       nullptr,
                                       nullptr,
                                       nullptr,
                                       external,
                                       napi_default,
                                       nullptr};
      status = napi_define_properties(env, obj, 1, &desc);
    }
  }
#else  // NAPI_VERSION >= 5
  status = napi_add_finalizer(env, obj, data, finalizer, hint, nullptr);
#endif
  return status;
}

// For use in JS to C++ callback wrappers to catch any Napi::Error exceptions
// and rethrow them as JavaScript exceptions before returning from the callback.
template <typename Callable>
inline napi_value WrapCallback(Callable callback) {
#ifdef NAPI_CPP_EXCEPTIONS
  try {
    return callback();
  } catch (const Error& e) {
    e.ThrowAsJavaScriptException();
    return nullptr;
  }
#else   // NAPI_CPP_EXCEPTIONS
  // When C++ exceptions are disabled, errors are immediately thrown as JS
  // exceptions, so there is no need to catch and rethrow them here.
  return callback();
#endif  // NAPI_CPP_EXCEPTIONS
}

// For use in JS to C++ void callback wrappers to catch any Napi::Error
// exceptions and rethrow them as JavaScript exceptions before returning from
// the callback.
template <typename Callable>
inline void WrapVoidCallback(Callable callback) {
#ifdef NAPI_CPP_EXCEPTIONS
  try {
    callback();
  } catch (const Error& e) {
    e.ThrowAsJavaScriptException();
  }
#else   // NAPI_CPP_EXCEPTIONS
  // When C++ exceptions are disabled, errors are immediately thrown as JS
  // exceptions, so there is no need to catch and rethrow them here.
  callback();
#endif  // NAPI_CPP_EXCEPTIONS
}

template <typename Callable, typename Return>
struct CallbackData {
  static inline napi_value Wrapper(napi_env env, napi_callback_info info) {
    return details::WrapCallback([&] {
      CallbackInfo callbackInfo(env, info);
      CallbackData* callbackData =
          static_cast<CallbackData*>(callbackInfo.Data());
      callbackInfo.SetData(callbackData->data);
      return callbackData->callback(callbackInfo);
    });
  }

  Callable callback;
  void* data;
};

template <typename Callable>
struct CallbackData<Callable, void> {
  static inline napi_value Wrapper(napi_env env, napi_callback_info info) {
    return details::WrapCallback([&] {
      CallbackInfo callbackInfo(env, info);
      CallbackData* callbackData =
          static_cast<CallbackData*>(callbackInfo.Data());
      callbackInfo.SetData(callbackData->data);
      callbackData->callback(callbackInfo);
      return nullptr;
    });
  }

  Callable callback;
  void* data;
};

template <void (*Callback)(const CallbackInfo& info)>
napi_value TemplatedVoidCallback(napi_env env,
                                 napi_callback_info info) NAPI_NOEXCEPT {
  return details::WrapCallback([&] {
    CallbackInfo cbInfo(env, info);
    Callback(cbInfo);
    return nullptr;
  });
}

template <Napi::Value (*Callback)(const CallbackInfo& info)>
napi_value TemplatedCallback(napi_env env,
                             napi_callback_info info) NAPI_NOEXCEPT {
  return details::WrapCallback([&] {
    CallbackInfo cbInfo(env, info);
    return Callback(cbInfo);
  });
}

template <typename T,
          Napi::Value (T::*UnwrapCallback)(const CallbackInfo& info)>
napi_value TemplatedInstanceCallback(napi_env env,
                                     napi_callback_info info) NAPI_NOEXCEPT {
  return details::WrapCallback([&] {
    CallbackInfo cbInfo(env, info);
    T* instance = T::Unwrap(cbInfo.This().As<Object>());
    return (instance->*UnwrapCallback)(cbInfo);
  });
}

template <typename T, void (T::*UnwrapCallback)(const CallbackInfo& info)>
napi_value TemplatedInstanceVoidCallback(napi_env env, napi_callback_info info)
    NAPI_NOEXCEPT {
  return details::WrapCallback([&] {
    CallbackInfo cbInfo(env, info);
    T* instance = T::Unwrap(cbInfo.This().As<Object>());
    (instance->*UnwrapCallback)(cbInfo);
    return nullptr;
  });
}

template <typename T, typename Finalizer, typename Hint = void>
struct FinalizeData {
  static inline void Wrapper(napi_env env,
                             void* data,
                             void* finalizeHint) NAPI_NOEXCEPT {
    WrapVoidCallback([&] {
      FinalizeData* finalizeData = static_cast<FinalizeData*>(finalizeHint);
      finalizeData->callback(Env(env), static_cast<T*>(data));
      delete finalizeData;
    });
  }

  static inline void WrapperWithHint(napi_env env,
                                     void* data,
                                     void* finalizeHint) NAPI_NOEXCEPT {
    WrapVoidCallback([&] {
      FinalizeData* finalizeData = static_cast<FinalizeData*>(finalizeHint);
      finalizeData->callback(
          Env(env), static_cast<T*>(data), finalizeData->hint);
      delete finalizeData;
    });
  }

  Finalizer callback;
  Hint* hint;
};

#if (NAPI_VERSION > 3 && NAPI_HAS_THREADS)
template <typename ContextType = void,
          typename Finalizer = std::function<void(Env, void*, ContextType*)>,
          typename FinalizerDataType = void>
struct ThreadSafeFinalize {
  static inline void Wrapper(napi_env env,
                             void* rawFinalizeData,
                             void* /* rawContext */) {
    if (rawFinalizeData == nullptr) return;

    ThreadSafeFinalize* finalizeData =
        static_cast<ThreadSafeFinalize*>(rawFinalizeData);
    finalizeData->callback(Env(env));
    delete finalizeData;
  }

  static inline void FinalizeWrapperWithData(napi_env env,
                                             void* rawFinalizeData,
                                             void* /* rawContext */) {
    if (rawFinalizeData == nullptr) return;

    ThreadSafeFinalize* finalizeData =
        static_cast<ThreadSafeFinalize*>(rawFinalizeData);
    finalizeData->callback(Env(env), finalizeData->data);
    delete finalizeData;
  }

  static inline void FinalizeWrapperWithContext(napi_env env,
                                                void* rawFinalizeData,
                                                void* rawContext) {
    if (rawFinalizeData == nullptr) return;

    ThreadSafeFinalize* finalizeData =
        static_cast<ThreadSafeFinalize*>(rawFinalizeData);
    finalizeData->callback(Env(env), static_cast<ContextType*>(rawContext));
    delete finalizeData;
  }

  static inline void FinalizeFinalizeWrapperWithDataAndContext(
      napi_env env, void* rawFinalizeData, void* rawContext) {
    if (rawFinalizeData == nullptr) return;

    ThreadSafeFinalize* finalizeData =
        static_cast<ThreadSafeFinalize*>(rawFinalizeData);
    finalizeData->callback(
        Env(env), finalizeData->data, static_cast<ContextType*>(rawContext));
    delete finalizeData;
  }

  FinalizerDataType* data;
  Finalizer callback;
};

template <typename ContextType, typename DataType, typename CallJs, CallJs call>
inline typename std::enable_if<call != static_cast<CallJs>(nullptr)>::type
CallJsWrapper(napi_env env, napi_value jsCallback, void* context, void* data) {
  call(env,
       Function(env, jsCallback),
       static_cast<ContextType*>(context),
       static_cast<DataType*>(data));
}

template <typename ContextType, typename DataType, typename CallJs, CallJs call>
inline typename std::enable_if<call == static_cast<CallJs>(nullptr)>::type
CallJsWrapper(napi_env env,
              napi_value jsCallback,
              void* /*context*/,
              void* /*data*/) {
  if (jsCallback != nullptr) {
    Function(env, jsCallback).Call(0, nullptr);
  }
}

#if NAPI_VERSION > 4

template <typename CallbackType, typename TSFN>
napi_value DefaultCallbackWrapper(napi_env /*env*/, std::nullptr_t /*cb*/) {
  return nullptr;
}

template <typename CallbackType, typename TSFN>
napi_value DefaultCallbackWrapper(napi_env /*env*/, Napi::Function cb) {
  return cb;
}

#else
template <typename CallbackType, typename TSFN>
napi_value DefaultCallbackWrapper(napi_env env, Napi::Function cb) {
  if (cb.IsEmpty()) {
    return TSFN::EmptyFunctionFactory(env);
  }
  return cb;
}
#endif  // NAPI_VERSION > 4
#endif  // NAPI_VERSION > 3 && NAPI_HAS_THREADS

template <typename Getter, typename Setter>
struct AccessorCallbackData {
  static inline napi_value GetterWrapper(napi_env env,
                                         napi_callback_info info) {
    return details::WrapCallback([&] {
      CallbackInfo callbackInfo(env, info);
      AccessorCallbackData* callbackData =
          static_cast<AccessorCallbackData*>(callbackInfo.Data());
      callbackInfo.SetData(callbackData->data);
      return callbackData->getterCallback(callbackInfo);
    });
  }

  static inline napi_value SetterWrapper(napi_env env,
                                         napi_callback_info info) {
    return details::WrapCallback([&] {
      CallbackInfo callbackInfo(env, info);
      AccessorCallbackData* callbackData =
          static_cast<AccessorCallbackData*>(callbackInfo.Data());
      callbackInfo.SetData(callbackData->data);
      callbackData->setterCallback(callbackInfo);
      return nullptr;
    });
  }

  Getter getterCallback;
  Setter setterCallback;
  void* data;
};

}  // namespace details

#ifndef NODE_ADDON_API_DISABLE_DEPRECATED
#include "napi-inl.deprecated.h"
#endif  // !NODE_ADDON_API_DISABLE_DEPRECATED

////////////////////////////////////////////////////////////////////////////////
// Module registration
////////////////////////////////////////////////////////////////////////////////

// Register an add-on based on an initializer function.
#define NODE_API_MODULE(modname, regfunc)                                      \
  static napi_value __napi_##regfunc(napi_env env, napi_value exports) {       \
    return Napi::RegisterModule(env, exports, regfunc);                        \
  }                                                                            \
  NAPI_MODULE(modname, __napi_##regfunc)

// Register an add-on based on a subclass of `Addon<T>` with a custom Node.js
// module name.
#define NODE_API_NAMED_ADDON(modname, classname)                               \
  static napi_value __napi_##classname(napi_env env, napi_value exports) {     \
    return Napi::RegisterModule(env, exports, &classname::Init);               \
  }                                                                            \
  NAPI_MODULE(modname, __napi_##classname)

// Register an add-on based on a subclass of `Addon<T>` with the Node.js module
// name given by node-gyp from the `target_name` in binding.gyp.
#define NODE_API_ADDON(classname)                                              \
  NODE_API_NAMED_ADDON(NODE_GYP_MODULE_NAME, classname)

// Adapt the NAPI_MODULE registration function:
//  - Wrap the arguments in NAPI wrappers.
//  - Catch any NAPI errors and rethrow as JS exceptions.
inline napi_value RegisterModule(napi_env env,
                                 napi_value exports,
                                 ModuleRegisterCallback registerCallback) {
  return details::WrapCallback([&] {
    return napi_value(
        registerCallback(Napi::Env(env), Napi::Object(env, exports)));
  });
}

////////////////////////////////////////////////////////////////////////////////
// Maybe class
////////////////////////////////////////////////////////////////////////////////

template <class T>
bool Maybe<T>::IsNothing() const {
  return !_has_value;
}

template <class T>
bool Maybe<T>::IsJust() const {
  return _has_value;
}

template <class T>
void Maybe<T>::Check() const {
  NAPI_CHECK(IsJust(), "Napi::Maybe::Check", "Maybe value is Nothing.");
}

template <class T>
T Maybe<T>::Unwrap() const {
  NAPI_CHECK(IsJust(), "Napi::Maybe::Unwrap", "Maybe value is Nothing.");
  return _value;
}

template <class T>
T Maybe<T>::UnwrapOr(const T& default_value) const {
  return _has_value ? _value : default_value;
}

template <class T>
bool Maybe<T>::UnwrapTo(T* out) const {
  if (IsJust()) {
    *out = _value;
    return true;
  };
  return false;
}

template <class T>
bool Maybe<T>::operator==(const Maybe& other) const {
  return (IsJust() == other.IsJust()) &&
         (!IsJust() || Unwrap() == other.Unwrap());
}

template <class T>
bool Maybe<T>::operator!=(const Maybe& other) const {
  return !operator==(other);
}

template <class T>
Maybe<T>::Maybe() : _has_value(false) {}

template <class T>
Maybe<T>::Maybe(const T& t) : _has_value(true), _value(t) {}

template <class T>
inline Maybe<T> Nothing() {
  return Maybe<T>();
}

template <class T>
inline Maybe<T> Just(const T& t) {
  return Maybe<T>(t);
}

////////////////////////////////////////////////////////////////////////////////
// Env class
////////////////////////////////////////////////////////////////////////////////

inline Env::Env(napi_env env) : _env(env) {}

inline Env::operator napi_env() const {
  return _env;
}

inline Object Env::Global() const {
  napi_value value;
  napi_status status = napi_get_global(*this, &value);
  NAPI_THROW_IF_FAILED(*this, status, Object());
  return Object(*this, value);
}

inline Value Env::Undefined() const {
  napi_value value;
  napi_status status = napi_get_undefined(*this, &value);
  NAPI_THROW_IF_FAILED(*this, status, Value());
  return Value(*this, value);
}

inline Value Env::Null() const {
  napi_value value;
  napi_status status = napi_get_null(*this, &value);
  NAPI_THROW_IF_FAILED(*this, status, Value());
  return Value(*this, value);
}

inline bool Env::IsExceptionPending() const {
  bool result;
  napi_status status = napi_is_exception_pending(_env, &result);
  if (status != napi_ok)
    result = false;  // Checking for a pending exception shouldn't throw.
  return result;
}

inline Error Env::GetAndClearPendingException() const {
  napi_value value;
  napi_status status = napi_get_and_clear_last_exception(_env, &value);
  if (status != napi_ok) {
    // Don't throw another exception when failing to get the exception!
    return Error();
  }
  return Error(_env, value);
}

inline MaybeOrValue<Value> Env::RunScript(const char* utf8script) const {
  String script = String::New(_env, utf8script);
  return RunScript(script);
}

inline MaybeOrValue<Value> Env::RunScript(const std::string& utf8script) const {
  return RunScript(utf8script.c_str());
}

inline MaybeOrValue<Value> Env::RunScript(String script) const {
  napi_value result;
  napi_status status = napi_run_script(_env, script, &result);
  NAPI_RETURN_OR_THROW_IF_FAILED(
      _env, status, Napi::Value(_env, result), Napi::Value);
}

#if NAPI_VERSION > 2
template <typename Hook, typename Arg>
void Env::CleanupHook<Hook, Arg>::Wrapper(void* data) NAPI_NOEXCEPT {
  auto* cleanupData =
      static_cast<typename Napi::Env::CleanupHook<Hook, Arg>::CleanupData*>(
          data);
  cleanupData->hook();
  delete cleanupData;
}

template <typename Hook, typename Arg>
void Env::CleanupHook<Hook, Arg>::WrapperWithArg(void* data) NAPI_NOEXCEPT {
  auto* cleanupData =
      static_cast<typename Napi::Env::CleanupHook<Hook, Arg>::CleanupData*>(
          data);
  cleanupData->hook(static_cast<Arg*>(cleanupData->arg));
  delete cleanupData;
}
#endif  // NAPI_VERSION > 2

#if NAPI_VERSION > 5
template <typename T, Env::Finalizer<T> fini>
inline void Env::SetInstanceData(T* data) const {
  napi_status status = napi_set_instance_data(
      _env,
      data,
      [](napi_env env, void* data, void*) { fini(env, static_cast<T*>(data)); },
      nullptr);
  NAPI_THROW_IF_FAILED_VOID