// @flow

import type {Root} from 'postcss';
import type {Asset, Dependency} from '@parcel/types';
import typeof PostCSS from 'postcss';
// $FlowFixMe - init for browser build.
import init, {bundleAsync} from 'lightningcss';

import invariant from 'assert';
import nullthrows from 'nullthrows';
import SourceMap from '@parcel/source-map';
import {Packager} from '@parcel/plugin';
import {convertSourceLocationToHighlight} from '@parcel/diagnostic';
import {
  PromiseQueue,
  replaceInlineReferences,
  replaceURLReferences,
} from '@parcel/utils';

export default (new Packager({
  async package({
    bundle,
    bundleGraph,
    getInlineBundleContents,
    getSourceMapReference,
    logger,
    options,
  }) {
    // Inline style attributes are parsed differently from full CSS files.
    if (bundle.bundleBehavior === 'inline') {
      let entry = bundle.getMainEntry();
      if (entry?.meta.type === 'attr') {
        return replaceReferences(
          bundle,
          bundleGraph,
          await entry.getCode(),
          await entry.getMap(),
          getInlineBundleContents,
        );
      }
    }

    let queue = new PromiseQueue({
      maxConcurrent: 32,
    });
    let hoistedImports = [];
    let assetsByPlaceholder = new Map();
    let entry = null;
    let entryContents = '';

    bundle.traverse({
      enter: (node, context) => {
        if (node.type === 'asset' && !context) {
          // If there is only one entry, we'll use it directly.
          // Otherwise, we'll create a fake bundle entry with @import rules for each root asset.
          if (entry == null) {
            entry = node.value.id;
          } else {
            entry = bundle.id;
          }

          assetsByPlaceholder.set(node.value.id, node.value);
          entryContents += `@import "${node.value.id}";\n`;
        }
        return true;
      },
      exit: node => {
        if (node.type === 'dependency') {
          let resolved = bundleGraph.getResolvedAsset(node.value, bundle);

          // Hoist unresolved external dependencies (i.e. http: imports)
          if (
            node.value.priority === 'sync' &&
            !bundleGraph.isDependencySkipped(node.value) &&
            !resolved
          ) {
            hoistedImports.push(node.value.specifier);
          }

          if (resolved && bundle.hasAsset(resolved)) {
            assetsByPlaceholder.set(
              node.value.meta.placeholder ?? node.value.specifier,
              resolved,
            );
          }

          return;
        }

        let asset = node.value;
        queue.add(() => {
          if (
            !asset.symbols.isCleared &&
            options.mode === 'production' &&
            asset.astGenerator?.type === 'postcss'
          ) {
            // a CSS Modules asset
            return processCSSModule(
              options,
              logger,
              bundleGraph,
              bundle,
              asset,
            );
          } else {
            return Promise.all([
              asset,
              asset.getCode().then((css: string) => {
                // Replace CSS variable references with resolved symbols.
                if (asset.meta.hasReferences) {
                  let replacements = new Map();
                  for (let dep of asset.getDependencies()) {
                    for (let [exported, {local}] of dep.symbols) {
                      let resolved = bundleGraph.getResolvedAsset(dep, bundle);
                      if (resolved) {
                        let resolution = bundleGraph.getSymbolResolution(
                          resolved,
                          exported,
                          bundle,
                        );
                        if (resolution.symbol) {
                          replacements.set(local, resolution.symbol);
                        }
                      }
                    }
                  }
                  if (replacements.size > 0) {
                    let regex = new RegExp(
                      [...replacements.keys()].join('|'),
                      'g',
                    );
                    css = css.replace(regex, m =>
                      escapeDashedIdent(replacements.get(m) || m),
                    );
                  }
                }

                return css;
              }),
              bundle.env.sourceMap ? asset.getMap() : null,
            ]);
          }
        });
      },
    });

    let outputs = new Map(
      (await queue.run()).map(([asset, code, map]) => [asset, [code, map]]),
    );
    let map = new SourceMap(options.projectRoot);

    // $FlowFixMe
    if (process.browser) {
      await init();
    }

    let res = await bundleAsync({
      filename: nullthrows(entry),
      sourceMap: !!bundle.env.sourceMap,
      resolver: {
        resolve(specifier) {
          return specifier;
        },
        async read(file) {
          if (file === bundle.id) {
            return entryContents;
          }

          let 