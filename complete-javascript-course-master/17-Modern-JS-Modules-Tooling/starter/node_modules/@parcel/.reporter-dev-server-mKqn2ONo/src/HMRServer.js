// @flow

import type {
  Asset,
  BundleGraph,
  Dependency,
  NamedBundle,
  PackagedBundle,
  PluginOptions,
} from '@parcel/types';
import type {Diagnostic} from '@parcel/diagnostic';
import type {AnsiDiagnosticResult} from '@parcel/utils';
import type {
  ServerError,
  HMRServerOptions,
  Request,
  Response,
} from './types.js.flow';
import {setHeaders, SOURCES_ENDPOINT} from './Server';

import nullthrows from 'nullthrows';
import url from 'url';
import mime from 'mime-types';
import WebSocket from 'ws';
import invariant from 'assert';
import {
  ansiHtml,
  createHTTPServer,
  prettyDiagnostic,
  PromiseQueue,
} from '@parcel/utils';

export type HMRAsset = {|
  id: string,
  url: string,
  type: string,
  output: string,
  envHash: string,
  outputFormat: string,
  depsByBundle: {[string]: {[string]: string, ...}, ...},
|};

export type HMRMessage =
  | {|
      type: 'update',
      assets: Array<HMRAsset>,
    |}
  | {|
      type: 'error',
      diagnostics: {|
        ansi: Array<AnsiDiagnosticResult>,
        html: Array<$Rest<AnsiDiagnosticResult, {|codeframe: string|}>>,
      |},
    |};

const FS_CONCURRENCY = 64;
const HMR_ENDPOINT = '/__parcel_hmr';

export default class HMRServer {
  wss: WebSocket.Server;
  unresolvedError: HMRMessage | null = null;
  options: HMRServerOptions;
  bundleGraph: BundleGraph<PackagedBundle> | BundleGraph<NamedBundle> | null =
    null;
  stopServer: ?() => Promise<void>;

  constructor(options: HMRServerOptions) {
    this.options = options;
  }

  async start() {
    let server = this.options.devServer;
    if (!server) {
      let result = await createHTTPServer({
        listener: (req, res) => {
          setHeaders(res);
          if (!this.handle(req, res)) {
            res.statusCode = 404;
            res.end();
          }
        },
      });
      server = result.server;
      server.listen(this.options.port, this.options.host);
      this.stopServer = result.stop;
    } else {
      this.options.addMiddleware?.((req, res) => this.handle(req, res));
    }
    this.wss = new WebSocket.Server({server});

    this.wss.on('connection', ws => {
      if (this.unresolvedError) {
        ws.send(JSON.stringify(